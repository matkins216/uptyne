--- a/lib/monitor-checker.ts
+++ b/lib/monitor-checker.ts
@@ -9,6 +9,18 @@ export interface CheckResult {
 }
 
 export async function checkWebsite(url: string): Promise<CheckResult> {
+    // Support ping:// and tcp:// targets
+    if (url.startsWith('ping://')) {
+        const host = url.replace('ping://', '')
+        return await checkPing(host, 5000)
+    }
+    if (url.startsWith('tcp://')) {
+        const u = new URL(url)
+        const host = u.hostname
+        const port = parseInt(u.port) || 80
+        return await checkTcp(host, port, 5000)
+    }
+
     const startTime = Date.now()
 
     try {
@@ -34,3 +46,65 @@ export async function checkWebsite(url: string): Promise<CheckResult> {
         }
     }
 }
+
+async function checkTcp(host: string, port: number, timeoutMs: number): Promise<CheckResult> {
+    const net = await import('node:net')
+    const start = process.hrtime.bigint()
+    return new Promise<CheckResult>((resolve) => {
+        const socket = new net.Socket()
+        let settled = false
+        const finish = (status: 'up' | 'down' | 'error', errorMessage?: string) => {
+            if (settled) return
+            settled = true
+            try { socket.destroy() } catch {}
+            const end = process.hrtime.bigint()
+            const responseTime = Math.max(0, Math.round(Number(end - start) / 1_000_000))
+            resolve({ status, responseTime, errorMessage })
+        }
+        socket.setTimeout(timeoutMs)
+        socket.once('connect', () => finish('up'))
+        socket.once('timeout', () => finish('down', `TCP timeout after ${timeoutMs}ms`))
+        socket.once('error', (e: any) => finish('down', `TCP error: ${e?.message}`))
+        socket.connect(port, host)
+    })
+}
+
+async function checkPing(host: string, timeoutMs: number): Promise<CheckResult> {
+    const cp = await import('node:child_process')
+    const isWin = process.platform === 'win32'
+    const args = isWin ? ['-n', '1', '-w', String(timeoutMs), host] : ['-c', '1', host]
+    const start = process.hrtime.bigint()
+    return new Promise<CheckResult>((resolve) => {
+        const finish = (status: 'up' | 'down' | 'error', errorMessage?: string, parsedRttMs?: number) => {
+            const end = process.hrtime.bigint()
+            const wallMs = Math.max(0, Math.round(Number(end - start) / 1_000_000))
+            resolve({ status, responseTime: parsedRttMs ?? wallMs, errorMessage })
+        }
+        try {
+            const child = cp.execFile(
+                'ping',
+                args,
+                { timeout: timeoutMs, encoding: 'utf8' },
+                (err, stdout) => {
+                    if (err) {
+                        const rtt = parseRttMs(stdout)
+                        return finish('down', `Ping failed: ${err.message}`, rtt)
+                    }
+                    const rtt = parseRttMs(stdout)
+                    return finish('up', undefined, rtt)
+                }
+            )
+        } catch (e: any) {
+            return finish('error', `Failed to spawn ping: ${e?.message}`)
+        }
+    })
+}
+
+function parseRttMs(output?: string): number | undefined {
+    if (!output) return undefined
+    const m1 = output.match(/time[=<]\s*(\d+(?:\.\d+)?)\s*ms/i)
+    if (m1) return Number(m1[1])
+    const m2 = output.match(/=\s*([\d.]+)\/([\d.]+)\/([\d.]+)\/([\d.]+)\s*ms/)
+    if (m2) return Number(m2[2])
+    return undefined
+}
+